<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Artist Canvas - Real-time Creative AI</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e1e2e, #2d2d44);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .controls {
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ff6b6b;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        button.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        button.save {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        button.stopping {
            background: linear-gradient(45deg, #feca57, #ff9ff3);
            box-shadow: 0 4px 15px rgba(254, 202, 87, 0.3);
        }

        #canvas {
            background: radial-gradient(circle at center, #0f0f1e, #000);
            cursor: crosshair;
            flex: 1;
        }

        .value-display {
            color: #ff6b6b;
            font-size: 11px;
            font-weight: bold;
        }

        .ai-controls {
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            padding-left: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-display {
            color: #4ecdc4;
            font-size: 12px;
            font-weight: bold;
            padding: 5px 10px;
            background: rgba(78, 205, 196, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            max-width: 200px;
        }

        .connection-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
        }

        .connected {
            background: rgba(78, 205, 196, 0.1);
            color: #4ecdc4;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .disconnected {
            background: rgba(255, 107, 107, 0.1);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .thinking-indicator {
            display: none;
            color: #feca57;
            font-size: 12px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label>Brush Size</label>
            <input type="range" id="brushSize" min="5" max="50" value="20">
            <span class="value-display" id="brushSizeValue">20</span>
        </div>
        <div class="control-group">
            <label>Flow Rate</label>
            <input type="range" id="flowRate" min="0.1" max="2" step="0.1" value="1">
            <span class="value-display" id="flowRateValue">1.0</span>
        </div>
        <div class="control-group">
            <label>Particles</label>
            <input type="range" id="particleCount" min="5" max="30" value="15">
            <span class="value-display" id="particleCountValue">15</span>
        </div>
        <div class="control-group">
            <label>Turbulence</label>
            <input type="range" id="turbulence" min="0" max="10" value="3">
            <span class="value-display" id="turbulenceValue">3</span>
        </div>
        <div class="control-group">
            <label>Color</label>
            <input type="color" id="brushColor" value="#ff6b6b">
        </div>
        <button id="clearCanvas">Clear Canvas</button>

        <div class="ai-controls">
            <button id="toggleAI">Start LLM Artist</button>
            <button id="saveCanvas" class="save">Save Canvas</button>
            <div class="connection-status disconnected" id="connectionStatus">Backend Offline</div>
            <div class="thinking-indicator" id="thinkingIndicator">ðŸ¤– AI Thinking...</div>
            <div class="status-display" id="aiStatus">Connect to Python backend to start</div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Create permanent canvas layer
        const permanentCanvas = document.createElement('canvas');
        const permanentCtx = permanentCanvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.querySelector('.controls').offsetHeight;
            permanentCanvas.width = canvas.width;
            permanentCanvas.height = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Brush settings
        let brushSize = 20;
        let flowRate = 1;
        let particleCount = 15;
        let turbulence = 3;
        let brushColor = '#ff6b6b';

        // Particle system
        let particles = [];
        let isDrawing = false;
        let mouseX = 0;
        let mouseY = 0;
        let prevMouseX = 0;
        let prevMouseY = 0;

        // LLM Artist system
        let isStopping = false;
        let aiActive = false;
        let aiX = canvas.width / 2;
        let aiY = canvas.height / 2;
        let aiPrevX = aiX;
        let aiPrevY = aiY;
        let isConnected = false;
        let lastCanvasState = null;
        let aiActionQueue = [];
        let isProcessingAction = false;

        // WebSocket connection to Python backend
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connectToBackend() {
            try {
                ws = new WebSocket('ws://localhost:8765');

                ws.onopen = function() {
                    console.log('Connected to LLM Artist backend');
                    isConnected = true;
                    reconnectAttempts = 0;
                    updateConnectionStatus();
                    document.getElementById('aiStatus').textContent = 'Connected! Ready to create art.';
                };

                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('Received from backend:', data);

                        if (data.type === 'action') {
                            executeAIAction(data);
                        } else if (data.type === 'thinking') {
                            if (data.message) {
                                document.getElementById('aiStatus').textContent = data.message;
                            }
                            showThinkingIndicator(data.show);
                        } else if (data.type === 'ai_started') {
                            console.log('AI confirmed started by backend');
                            isStopping = false;
                            updateToggleButton();
                            document.getElementById('aiStatus').textContent = data.message;
                        } else if (data.type === 'ai_stopped') {
                    console.log('AI confirmed stopped by backend');
                    // Actually stop everything without sending another command
                    aiActive = false;
                    isStopping = false;
                    updateToggleButton();
                    showThinkingIndicator(false);
                    document.getElementById('aiStatus').textContent = data.message;

                    // Clear the interval
                    if (aiInterval) {
                        clearInterval(aiInterval);
                        aiInterval = null;
                    }
                }
                    } catch (e) {
                        console.error('Error parsing backend message:', e);
                    }
};


                ws.onclose = function() {
                    console.log('Disconnected from backend');
                    isConnected = false;
                    updateConnectionStatus();

                    if (aiActive) {
                        stopAI();
                    }

                    // Try to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        setTimeout(connectToBackend, 2000);
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    isConnected = false;
                    updateConnectionStatus();
                };

            } catch (error) {
                console.error('Failed to connect to backend:', error);
                isConnected = false;
                updateConnectionStatus();
            }
        }

        function updateConnectionStatus() {
            const statusElement = document.getElementById('connectionStatus');
            if (isConnected) {
                statusElement.textContent = 'Backend Connected';
                statusElement.className = 'connection-status connected';
            } else {
                statusElement.textContent = 'Backend Offline';
                statusElement.className = 'connection-status disconnected';
                document.getElementById('aiStatus').textContent = 'Start Python backend to connect';
            }
        }

        function showThinkingIndicator(show) {
            const indicator = document.getElementById('thinkingIndicator');
            indicator.style.display = show ? 'block' : 'none';
        }

        function captureCanvasState() {
            // Create a lower resolution version for the LLM to analyze
            const smallCanvas = document.createElement('canvas');
            const smallCtx = smallCanvas.getContext('2d');
            smallCanvas.width = 256;
            smallCanvas.height = 256;

            // Draw current state to small canvas
            smallCtx.drawImage(canvas, 0, 0, smallCanvas.width, smallCanvas.height);

            return smallCanvas.toDataURL('image/jpeg', 0.7);
        }

        function sendCanvasToBackend() {
            if (!isConnected || !ws) return;

            const canvasState = captureCanvasState();
            const message = {
                type: 'canvas_state',
                image: canvasState,
                canvas_width: canvas.width,
                canvas_height: canvas.height,
                current_settings: {
                    brush_size: brushSize,
                    flow_rate: flowRate,
                    particle_count: particleCount,
                    turbulence: turbulence,
                    color: brushColor
                },
                ai_position: { x: aiX, y: aiY }
            };

            ws.send(JSON.stringify(message));
        }

        function executeAIAction(action) {
            console.log('Executing AI action:', action);

            // Update brush settings if provided
            if (action.brush_size !== undefined) {
                brushSize = action.brush_size;
                document.getElementById('brushSize').value = brushSize;
                document.getElementById('brushSizeValue').textContent = brushSize;
            }
            if (action.flow_rate !== undefined) {
                flowRate = action.flow_rate;
                document.getElementById('flowRate').value = flowRate;
                document.getElementById('flowRateValue').textContent = flowRate.toFixed(1);
            }
            if (action.particle_count !== undefined) {
                particleCount = action.particle_count;
                document.getElementById('particleCount').value = particleCount;
                document.getElementById('particleCountValue').textContent = particleCount;
            }
            if (action.turbulence !== undefined) {
                turbulence = action.turbulence;
                document.getElementById('turbulence').value = turbulence;
                document.getElementById('turbulenceValue').textContent = turbulence;
            }
            if (action.color) {
                brushColor = action.color;
                document.getElementById('brushColor').value = brushColor;
            }

            // Execute movement action
            if (action.action === 'move_to') {
                aiPrevX = aiX;
                aiPrevY = aiY;
                aiX = Math.max(0, Math.min(canvas.width, action.x));
                aiY = Math.max(0, Math.min(canvas.height, action.y));
                createParticles(aiX, aiY);
            } else if (action.action === 'draw_line') {
                // Draw line with multiple points
                const steps = action.steps || 20;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = aiX + (action.to_x - aiX) * t;
                    const y = aiY + (action.to_y - aiY) * t;
                    createParticles(x, y);
                }
                aiPrevX = aiX;
                aiPrevY = aiY;
                aiX = action.to_x;
                aiY = action.to_y;
            } else if (action.action === 'draw_curve') {
                // Draw bezier curve
                const steps = action.steps || 30;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    // Quadratic bezier curve
                    const x = Math.pow(1-t, 2) * aiX + 2*(1-t)*t * action.control_x + Math.pow(t, 2) * action.end_x;
                    const y = Math.pow(1-t, 2) * aiY + 2*(1-t)*t * action.control_y + Math.pow(t, 2) * action.end_y;
                    createParticles(x, y);
                }
                aiPrevX = aiX;
                aiPrevY = aiY;
                aiX = action.end_x;
                aiY = action.end_y;
            }

            // Update status
            if (action.thought) {
                document.getElementById('aiStatus').textContent = action.thought;
            }
        }
        function updateToggleButton() {
            const button = document.getElementById('toggleAI');
            if (aiActive && !isStopping) {
                button.textContent = 'Stop LLM Artist';
                button.classList.add('active');
                button.classList.remove('stopping');
            } else if (isStopping) {
                button.textContent = 'Stopping...';
                button.classList.remove('active');
                button.classList.add('stopping');
            } else {
                button.textContent = 'Start LLM Artist';
                button.classList.remove('active', 'stopping');
            }
}

        function startAI() {
            if (!isConnected) {
                alert('Please start the Python backend first!');
                return;
            }

            aiActive = true;
            isStopping = false;
            updateToggleButton();

            // Send start command to backend
            ws.send(JSON.stringify({
                type: 'ai_control',
                command: 'start'
            }));

            document.getElementById('aiStatus').textContent = 'LLM Artist is creating...';

            // Initialize AI position
            aiX = canvas.width / 2;
            aiY = canvas.height / 2;
            aiPrevX = aiX;
            aiPrevY = aiY;

            // Start sending canvas state to backend
            sendCanvasToBackend();

            // Send canvas state every 3 seconds
            aiInterval = setInterval(() => {
                if (aiActive && isConnected && !isStopping) {
                    sendCanvasToBackend();
                }
            }, 3000);
        }


        function stopAI() {
            if (aiActive && !isStopping) {
                // Request graceful stop from backend
                isStopping = true;
                updateToggleButton();

                ws.send(JSON.stringify({
                    type: 'ai_control',
                    command: 'stop'
                }));

                document.getElementById('aiStatus').textContent = 'Stopping LLM Artist...';
                return;
            }

            // Actually stop everything
            aiActive = false;
            isStopping = false;
            updateToggleButton();
            showThinkingIndicator(false);

            if (aiInterval) {
                clearInterval(aiInterval);
                aiInterval = null;
            }
        }
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.decay = 0.005 + Math.random() * 0.01;
                this.size = Math.random() * 3 + 1;
                this.color = color;
                this.trail = [];
                this.maxTrailLength = 8;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = (Math.random() - 0.5) * 0.1;
            }

            update() {
                this.trail.push({x: this.x, y: this.y, life: this.life});
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                this.angle += this.spin;
                this.vx += Math.cos(this.angle) * turbulence * 0.01;
                this.vy += Math.sin(this.angle) * turbulence * 0.01;

                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;

                this.life -= this.decay;
                this.size *= 0.999;

                return this.life > 0;
            }

            draw() {
                if (permanentCanvas.width > 0 && permanentCanvas.height > 0) {
                    for (let i = 0; i < this.trail.length; i++) {
                        const point = this.trail[i];
                        const alpha = (point.life * (i / this.trail.length)) * 0.3;
                        const size = this.size * (i / this.trail.length);

                        permanentCtx.save();
                        permanentCtx.globalAlpha = alpha;
                        permanentCtx.fillStyle = this.color;
                        permanentCtx.beginPath();
                        permanentCtx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        permanentCtx.fill();
                        permanentCtx.restore();
                    }

                    if (this.life > 0.8) {
                        permanentCtx.save();
                        permanentCtx.globalAlpha = 0.6;
                        permanentCtx.fillStyle = this.color;
                        permanentCtx.beginPath();
                        permanentCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        permanentCtx.fill();
                        permanentCtx.restore();
                    }
                }

                ctx.save();
                ctx.globalAlpha = this.life * 0.8;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function createParticles(x, y) {
            const count = Math.floor(particleCount * flowRate);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const radius = Math.random() * brushSize;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                particles.push(new Particle(px, py, brushColor));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (permanentCanvas.width > 0 && permanentCanvas.height > 0) {
                ctx.drawImage(permanentCanvas, 0, 0);
            }

            particles = particles.filter(particle => {
                if (particle.update()) {
                    particle.draw();
                    return true;
                }
                return false;
            });

            // Draw brush stroke (human or AI)
            const currentX = aiActive ? aiX : mouseX;
            const currentY = aiActive ? aiY : mouseY;
            const prevX = aiActive ? aiPrevX : prevMouseX;
            const prevY = aiActive ? aiPrevY : prevMouseY;
            const drawing = (aiActive && isConnected) || isDrawing;

            if (drawing && permanentCanvas.width > 0 && permanentCanvas.height > 0) {
                permanentCtx.save();
                permanentCtx.globalAlpha = 0.3;
                permanentCtx.strokeStyle = brushColor;
                permanentCtx.lineWidth = brushSize * 0.3;
                permanentCtx.lineCap = 'round';
                permanentCtx.shadowBlur = 20;
                permanentCtx.shadowColor = brushColor;
                permanentCtx.beginPath();
                permanentCtx.moveTo(prevX, prevY);
                permanentCtx.lineTo(currentX, currentY);
                permanentCtx.stroke();
                permanentCtx.restore();
            }

            requestAnimationFrame(animate);
        }

        // Mouse events (only active when AI is not running)
        canvas.addEventListener('mousedown', (e) => {
            if (aiActive) return;
            isDrawing = true;
            mouseX = e.clientX;
            mouseY = e.clientY - document.querySelector('.controls').offsetHeight;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            createParticles(mouseX, mouseY);
        });

        canvas.addEventListener('mousemove', (e) => {
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY - document.querySelector('.controls').offsetHeight;

            if (isDrawing && !aiActive) {
                createParticles(mouseX, mouseY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (aiActive) return;
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            if (aiActive) return;
            isDrawing = false;
        });

        // Control updates
        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('flowRate').addEventListener('input', (e) => {
            flowRate = parseFloat(e.target.value);
            document.getElementById('flowRateValue').textContent = flowRate.toFixed(1);
        });

        document.getElementById('particleCount').addEventListener('input', (e) => {
            particleCount = parseInt(e.target.value);
            document.getElementById('particleCountValue').textContent = particleCount;
        });

        document.getElementById('turbulence').addEventListener('input', (e) => {
            turbulence = parseInt(e.target.value);
            document.getElementById('turbulenceValue').textContent = turbulence;
        });

        document.getElementById('brushColor').addEventListener('input', (e) => {
            brushColor = e.target.value;
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            permanentCtx.clearRect(0, 0, permanentCanvas.width, permanentCanvas.height);
            particles = [];
        });

        document.getElementById('toggleAI').addEventListener('click', () => {
            if (aiActive) {
                stopAI();
            } else {
                startAI();
            }
        });

        document.getElementById('saveCanvas').addEventListener('click', () => {
            // Create a link to download the canvas
            const link = document.createElement('a');
            link.download = `llm_artwork_${new Date().getTime()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });

        // Initialize
        animate();
        connectToBackend();
    </script>
</body>
</html>
