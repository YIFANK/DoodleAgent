<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Painting Studio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .controls {
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .brush-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            margin-right: 20px;
            padding-right: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .brush-selector label {
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            outline: none;
            min-width: 120px;
        }

        select option {
            background: #2a2a2a;
            color: #fff;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-height: 14px;
        }

        .control-description {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
            margin-top: 2px;
            min-height: 12px;
            text-align: center;
        }

        input[type="range"] {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--thumb-color, #ff6b6b);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        #canvas {
            background: #ffffff;
            cursor: crosshair;
            flex: 1;
        }

        .value-display {
            color: var(--value-color, #ff6b6b);
            font-size: 11px;
            font-weight: bold;
        }

        /* Brush-specific theming */
        .flowing-theme {
            --thumb-color: #ff6b6b;
            --value-color: #ff6b6b;
        }

        .watercolor-theme {
            --thumb-color: #4a90e2;
            --value-color: #4a90e2;
        }

        .crayon-theme {
            --thumb-color: #d2691e;
            --value-color: #d2691e;
        }

        .oil-theme {
            --thumb-color: #8b4513;
            --value-color: #8b4513;
        }

        .eraser-theme {
            --thumb-color: #666666;
            --value-color: #666666;
        }

        .brush-info {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            color: #fff;
            font-size: 11px;
            max-width: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .brush-info.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="controls flowing-theme" id="controls">
        <div class="brush-selector">
            <label>Brush Type</label>
            <select id="brushSelector">
                <option value="flowing">Flowing Particle</option>
                <option value="watercolor">Watercolor</option>
                <option value="crayon">Crayon</option>
                <option value="oil">Oil Paint</option>
                <option value="eraser">Eraser</option>
            </select>
        </div>

        <div class="control-group">
            <label>Brush Size</label>
            <input type="range" id="brushSize" min="5" max="50" value="20">
            <span class="value-display" id="brushSizeValue">20</span>
        </div>

        <div class="control-group">
            <label id="param1Label">Flow Rate</label>
            <input type="range" id="param1" min="0.1" max="2" step="0.1" value="1.0">
            <span class="value-display" id="param1Value">1.0</span>
            <div class="control-description" id="param1Desc">Particle speed</div>
        </div>

        <div class="control-group">
            <label id="param2Label">Particles</label>
            <input type="range" id="param2" min="5" max="30" value="15">
            <span class="value-display" id="param2Value">15</span>
            <div class="control-description" id="param2Desc">Particle count</div>
        </div>

        <div class="control-group">
            <label id="param3Label">Turbulence</label>
            <input type="range" id="param3" min="0.1" max="2" step="0.1" value="1.0">
            <span class="value-display" id="param3Value">1.0</span>
            <div class="control-description" id="param3Desc">Chaos amount</div>
        </div>

        <div class="control-group">
            <label id="param4Label">Paper Roughness</label>
            <input type="range" id="param4" min="0" max="10" value="4">
            <span class="value-display" id="param4Value">4</span>
            <div class="control-description" id="param4Desc">Surface texture</div>
        </div>

        <div class="control-group">
            <label>Color</label>
            <input type="color" id="brushColor" value="#ff6b6b">
        </div>

        <button id="clearCanvas">Clear Canvas</button>
        <button id="saveCanvas">Save Canvas</button>
    </div>

    <div class="brush-info" id="brushInfo">
        <strong id="brushName">Flowing Particle Brush</strong><br>
        <span id="brushDescription">Dynamic particle system with flowing effects and turbulence.</span>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas layers for different brush types
        const wetLayer = document.createElement('canvas');
        const wetCtx = wetLayer.getContext('2d');
        const dryLayer = document.createElement('canvas');
        const dryCtx = dryLayer.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            const controlsHeight = document.querySelector('.controls').offsetHeight;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - controlsHeight;
            wetLayer.width = canvas.width;
            wetLayer.height = canvas.height;
            dryLayer.width = canvas.width;
            dryLayer.height = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Unified settings
        let currentBrush = 'flowing';
        let brushSize = 20;
        let param1 = 1.0;
        let param2 = 15;
        let param3 = 1.0;
        let param4 = 4;
        let brushColor = '#ff6b6b';
        
        // Particle systems
        let particles = [];
        let waterDroplets = [];
        let pigmentParticles = [];
        let waxParticles = [];
        let paintGlobs = [];
        let strokeHistory = [];
        let isDrawing = false;
        let mouseX = 0;
        let mouseY = 0;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let strokeLength = 0;
        let brushLoad = 1.0;

        // Brush configurations
        const brushConfigs = {
            flowing: {
                name: 'Flowing Particle Brush',
                description: 'Dynamic particle system with flowing effects and turbulence.',
                theme: 'flowing-theme',
                params: {
                    param1: { label: 'Flow Rate', desc: 'Particle speed', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Particles', desc: 'Particle count', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Turbulence', desc: 'Chaos amount', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Roughness', desc: 'Surface texture', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#ff6b6b'
            },
            watercolor: {
                name: 'Watercolor Brush',
                description: 'Realistic watercolor with bleeding and organic flow patterns.',
                theme: 'watercolor-theme',
                params: {
                    param1: { label: 'Water Content', desc: 'Controls bleeding', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Pigment Density', desc: 'Color intensity', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Flow Speed', desc: 'Water movement', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Texture', desc: 'Surface roughness', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#4a90e2'
            },
            crayon: {
                name: 'Crayon Brush',
                description: 'Textured waxy application with natural gaps and paper interaction.',
                theme: 'crayon-theme',
                params: {
                    param1: { label: 'Pressure', desc: 'Wax density', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Texture Strength', desc: 'Grain intensity', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Grain Size', desc: 'Texture scale', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Roughness', desc: 'Surface texture', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#d2691e'
            },
            oil: {
                name: 'Oil Paint Brush',
                description: 'Thick impasto application with natural paint depletion and streaking.',
                theme: 'oil-theme',
                params: {
                    param1: { label: 'Paint Thickness', desc: 'Impasto effect', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Viscosity', desc: 'Paint thickness', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Blending', desc: 'Edge softness', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Canvas Texture', desc: 'Surface drag', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#8b4513'
            },
            eraser: {
                name: 'Eraser Tool',
                description: 'Remove paint with soft, natural erasing effects.',
                theme: 'eraser-theme',
                params: {
                    param1: { label: 'Eraser Strength', desc: 'Erasing intensity', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Softness', desc: 'Edge softness', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Pressure', desc: 'Erasing pressure', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Texture', desc: 'Erasing texture', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#ffffff'
            }
        };

        // Switch brush type
        function switchBrush(brushType) {
            currentBrush = brushType;
            const config = brushConfigs[brushType];
            
            // Clear all particles
            particles = [];
            waterDroplets = [];
            pigmentParticles = [];
            waxParticles = [];
            paintGlobs = [];
            
            // Update theme
            const controls = document.getElementById('controls');
            controls.className = `controls ${config.theme}`;
            
            // Update brush info
            document.getElementById('brushName').textContent = config.name;
            document.getElementById('brushDescription').textContent = config.description;
            
            // Update parameter labels and settings
            Object.keys(config.params).forEach(paramKey => {
                const param = config.params[paramKey];
                const input = document.getElementById(paramKey);
                const label = document.getElementById(`${paramKey}Label`);
                const desc = document.getElementById(`${paramKey}Desc`);
                const value = document.getElementById(`${paramKey}Value`);
                
                label.textContent = param.label;
                desc.textContent = param.desc;
                input.min = param.min;
                input.max = param.max;
                input.step = param.step || 1;
                input.value = param.default;
                value.textContent = param.step === 0.1 ? param.default.toFixed(1) : param.default;
                
                // Update global variables
                window[paramKey] = param.default;
            });
            
            // Update brush color
            brushColor = config.color;
            document.getElementById('brushColor').value = config.color;
            
            // Show brush info briefly
            const brushInfo = document.getElementById('brushInfo');
            brushInfo.classList.add('visible');
            setTimeout(() => brushInfo.classList.remove('visible'), 3000);
        }

        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Particle classes
        class FlowingParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.decay = 0.005 + Math.random() * 0.01;
                this.size = Math.random() * 3 + 1;
                this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = (Math.random() - 0.5) * 0.1;
                this.trail = [];
                this.maxTrailLength = 8;
            }

            update() {
                // Add current position to trail
                this.trail.push({x: this.x, y: this.y, life: this.life});
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                this.angle += this.spin;
                this.vx += Math.cos(this.angle) * param3 * 0.01;
                this.vy += Math.sin(this.angle) * param3 * 0.01;
                this.x += this.vx * param1;
                this.y += this.vy * param1;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
                this.size *= 0.999;
                return this.life > 0;
            }

            draw() {
                // Draw trail on permanent canvas (dry layer)
                if (dryLayer.width > 0 && dryLayer.height > 0) {
                    for (let i = 0; i < this.trail.length; i++) {
                        const point = this.trail[i];
                        const alpha = (point.life * (i / this.trail.length)) * 0.3;
                        const size = this.size * (i / this.trail.length);
                        
                        dryCtx.save();
                        dryCtx.globalAlpha = alpha;
                        dryCtx.fillStyle = this.color;
                        dryCtx.beginPath();
                        dryCtx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        dryCtx.fill();
                        dryCtx.restore();
                    }

                    // Draw permanent mark when particle is fresh
                    if (this.life > 0.8) {
                        dryCtx.save();
                        dryCtx.globalAlpha = 0.6;
                        dryCtx.fillStyle = this.color;
                        dryCtx.beginPath();
                        dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        dryCtx.fill();
                        dryCtx.restore();
                    }
                }

                // Draw glowing particle on main canvas (temporary effect)
                ctx.save();
                ctx.globalAlpha = this.life * 0.8;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class WaterDroplet {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.originalSize = size;
                this.vx = (Math.random() - 0.5) * param3;
                this.vy = (Math.random() - 0.5) * param3;
                this.life = 1.0;
                this.evaporation = 0.002 + Math.random() * 0.003;
                this.color = color;
                this.opacity = 0.3 + Math.random() * 0.4;
                this.spread = 0;
                this.maxSpread = param1 * 20;
                this.absorbed = false;
                this.permanentMarks = [];
            }

            update() {
                this.vy += 0.01;
                if (Math.random() < param4 * 0.01) {
                    this.vx += (Math.random() - 0.5) * 0.1;
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.spread += 0.5;
                this.size = this.originalSize + this.spread * 0.3;
                this.life -= this.evaporation;
                this.opacity *= 0.998;

                // Create permanent bleeding marks as the droplet moves
                if (this.spread > 2 && !this.absorbed) {
                    this.createPermanentMark();
                }

                if (this.spread > this.maxSpread * 0.7 && !this.absorbed) {
                    this.absorbIntoPaper();
                    this.absorbed = true;
                }
                return this.life > 0 && this.opacity > 0.01;
            }

            createPermanentMark() {
                const rgb = hexToRgb(this.color);
                if (rgb && dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity * 0.4;
                    const gradient = dryCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                    gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)`);
                    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                    dryCtx.fillStyle = gradient;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }
            }

            absorbIntoPaper() {
                const rgb = hexToRgb(this.color);
                if (rgb && dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity * 0.8;
                    const gradient = dryCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                    gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`);
                    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                    dryCtx.fillStyle = gradient;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }
            }

            draw() {
                const rgb = hexToRgb(this.color);
                if (!rgb) return;
                wetCtx.save();
                wetCtx.globalAlpha = this.opacity;
                const gradient = wetCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`);
                gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                wetCtx.fillStyle = gradient;
                wetCtx.beginPath();
                wetCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                wetCtx.fill();
                wetCtx.restore();
            }
        }

        class WaxParticle {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.opacity = 0.6 + Math.random() * 0.4;
                this.settled = false;
                this.life = 1.0;
                this.decay = 0.002;
                this.displacement = { x: (Math.random() - 0.5) * param3, y: (Math.random() - 0.5) * param3 };
                this.paperSkip = Math.random() < (param4 * 0.01);
            }

            update() {
                if (!this.settled) {
                    this.x += this.displacement.x * 0.1;
                    this.y += this.displacement.y * 0.1;
                    this.displacement.x *= 0.9;
                    this.displacement.y *= 0.9;
                    if (Math.abs(this.displacement.x) < 0.1) this.settled = true;
                }
                this.life -= this.decay;
                return this.life > 0;
            }

            draw() {
                if (this.paperSkip) return;
                
                // Draw on permanent layer (dry layer) for consistency
                if (dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity * this.life;
                    dryCtx.fillStyle = this.color;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }
                
                // Also draw temporary effect on main canvas
                ctx.save();
                ctx.globalAlpha = this.opacity * this.life * 0.3;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class PaintGlob {
            constructor(x, y, color, size, thickness, strokePosition) {
                this.x = x;
                this.y = y;
                this.size = size * 1.2; // Increased base size for smoother coverage
                this.thickness = thickness;
                this.color = color;
                this.strokePosition = strokePosition;
                this.opacity = this.calculateOpacity();
                this.life = 1.0;
                this.decay = 0.0002; // Reduced decay for longer-lasting paint
                this.blendRadius = 0;
                this.maxBlend = thickness * 3; // Increased blend radius
                this.impasto = {
                    height: thickness * param1, // Paint buildup based on thickness param
                    flow: {
                        x: (Math.random() - 0.5) * 0.1 * param3,
                        y: (Math.random() - 0.5) * 0.1 * param3
                    }
                };
            }

            calculateOpacity() {
                // Higher base opacity for oil paint's rich coverage
                const baseOpacity = 0.9 + (this.thickness * 0.1);
                return baseOpacity;
            }

            update() {
                if (this.blendRadius < this.maxBlend) {
                    this.blendRadius += 0.02 * param3; // Slower blending
                    
                    // Smoother paint flow
                    this.x += this.impasto.flow.x;
                    this.y += this.impasto.flow.y;
                    this.impasto.flow.x *= 0.98;
                    this.impasto.flow.y *= 0.98;
                }
                this.life -= this.decay;
                return this.life > 0;
            }

            draw() {
                if (this.opacity <= 0) return;
                const rgb = hexToRgb(this.color);
                if (!rgb) return;
                
                // Draw on permanent layer with impasto effect
                if (dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    
                    // Base paint layer with consistent size
                    dryCtx.globalAlpha = this.opacity;
                    dryCtx.fillStyle = this.color;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size * 1.2, 0, Math.PI * 2); // Increased base size
                    dryCtx.fill();
                    
                    // Impasto highlight effect with minimal size reduction
                    dryCtx.globalAlpha = this.opacity * 0.4;
                    dryCtx.fillStyle = `rgba(255,255,255,0.2)`;
                    dryCtx.beginPath();
                    dryCtx.arc(
                        this.x - this.impasto.height, 
                        this.y - this.impasto.height, 
                        this.size * 0.995, // Less size reduction for highlight
                        0, Math.PI * 2
                    );
                    dryCtx.fill();
                    dryCtx.restore();
                }
                
                // Wet paint effect on main canvas with consistent size
                ctx.save();
                ctx.globalAlpha = this.opacity * 0.5;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 3;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.3, 0, Math.PI * 2); // Increased wet effect size
                ctx.fill();
                ctx.restore();
            }
        }

        // Create strokes based on current brush
        function createStroke(x, y) {
            switch (currentBrush) {
                case 'flowing':
                    createFlowingStroke(x, y);
                    break;
                case 'watercolor':
                    createWatercolorStroke(x, y);
                    break;
                case 'crayon':
                    createCrayonStroke(x, y);
                    break;
                case 'oil':
                    createOilPaintStroke(x, y);
                    break;
                case 'eraser':
                    createEraserStroke(x, y);
                    break;
            }
        }

        function createFlowingStroke(x, y) {
            const count = Math.floor(param2 * param1);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const radius = Math.random() * brushSize;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                particles.push(new FlowingParticle(px, py, brushColor));
            }

            // Create brush stroke connecting effect on permanent layer
            if (isDrawing && dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.globalAlpha = 0.3;
                dryCtx.strokeStyle = brushColor;
                dryCtx.lineWidth = brushSize * 0.3;
                dryCtx.lineCap = 'round';
                dryCtx.shadowBlur = 20;
                dryCtx.shadowColor = brushColor;
                dryCtx.beginPath();
                dryCtx.moveTo(prevMouseX, prevMouseY);
                dryCtx.lineTo(x, y);
                dryCtx.stroke();
                dryCtx.restore();
            }
        }

        function createWatercolorStroke(x, y) {
            const waterDropCount = Math.floor(brushSize * param1 * 0.3);
            for (let i = 0; i < waterDropCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * brushSize;
                const wx = x + Math.cos(angle) * radius;
                const wy = y + Math.sin(angle) * radius;
                const dropSize = 3 + Math.random() * 8;
                waterDroplets.push(new WaterDroplet(wx, wy, dropSize, brushColor));
            }
        }

        function createCrayonStroke(x, y) {
            const patchCount = Math.floor(brushSize * 0.8);
            for (let i = 0; i < patchCount; i++) {
                if (Math.random() < 0.4 + (param4 * 0.05)) continue;
                const angle = (Math.PI * 2 * i) / patchCount;
                const radius = Math.random() * brushSize * 0.8;
                const patchX = x + Math.cos(angle) * radius;
                const patchY = y + Math.sin(angle) * radius;
                const patchSize = (Math.random() * 3 + 1) * param1;
                waxParticles.push(new WaxParticle(patchX, patchY, brushColor, patchSize));
            }
        }

        function createOilPaintStroke(x, y) {
            const strokePos = Math.min(1, strokeLength / (brushSize * 8));
            brushLoad = Math.max(0.1, 1 - strokePos * 0.8);
            const baseParticleCount = strokePos < 0.3 ? 
                Math.floor(param2 * 0.4) : 
                Math.floor(param2 * (1 + strokePos * 1.5));
            const mainGlobCount = Math.floor(baseParticleCount * param1 * brushLoad);
            
            for (let i = 0; i < mainGlobCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * brushSize * (strokePos < 0.3 ? 0.6 : 1.2);
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                const globSize = strokePos < 0.3 ? 
                    (Math.random() * 2 + 3) * param1 * brushLoad : 
                    (Math.random() * 4 + 1) * param1 * Math.max(0.2, brushLoad);
                paintGlobs.push(new PaintGlob(px, py, brushColor, globSize, param1, strokePos));
            }
        }

        function createEraserStroke(x, y) {
            // Erase from the dry layer (permanent marks)
            if (dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.globalCompositeOperation = 'destination-out';
                
                // Create a soft eraser effect
                const eraserSize = brushSize * param1;
                const gradient = dryCtx.createRadialGradient(x, y, 0, x, y, eraserSize);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${param3 * 0.8})`);
                gradient.addColorStop(0.7, `rgba(255, 255, 255, ${param3 * 0.4})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                dryCtx.fillStyle = gradient;
                dryCtx.beginPath();
                dryCtx.arc(x, y, eraserSize, 0, Math.PI * 2);
                dryCtx.fill();
                
                // Add some texture variation based on param4
                if (param4 > 0) {
                    const textureCount = Math.floor(param4 * 2);
                    for (let i = 0; i < textureCount; i++) {
                        const angle = (Math.PI * 2 * i) / textureCount;
                        const radius = Math.random() * eraserSize * 0.8;
                        const tx = x + Math.cos(angle) * radius;
                        const ty = y + Math.sin(angle) * radius;
                        const textureSize = (Math.random() * 3 + 1) * param2 * 0.1;
                        
                        const textureGradient = dryCtx.createRadialGradient(tx, ty, 0, tx, ty, textureSize);
                        textureGradient.addColorStop(0, `rgba(255, 255, 255, ${param3 * 0.3})`);
                        textureGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        dryCtx.fillStyle = textureGradient;
                        dryCtx.beginPath();
                        dryCtx.arc(tx, ty, textureSize, 0, Math.PI * 2);
                        dryCtx.fill();
                    }
                }
                
                dryCtx.restore();
            }
            
            // Also erase from the wet layer for watercolor effects
            if (currentBrush === 'watercolor' && wetLayer.width > 0 && wetLayer.height > 0) {
                wetCtx.save();
                wetCtx.globalCompositeOperation = 'destination-out';
                
                const eraserSize = brushSize * param1 * 0.8;
                const gradient = wetCtx.createRadialGradient(x, y, 0, x, y, eraserSize);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${param3 * 0.6})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                wetCtx.fillStyle = gradient;
                wetCtx.beginPath();
                wetCtx.arc(x, y, eraserSize, 0, Math.PI * 2);
                wetCtx.fill();
                wetCtx.restore();
            }
            
            // Create connecting stroke effect for smooth erasing
            if (isDrawing && dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.globalCompositeOperation = 'destination-out';
                dryCtx.globalAlpha = param3 * 0.4;
                dryCtx.strokeStyle = 'rgba(255, 255, 255, 1)';
                dryCtx.lineWidth = brushSize * 0.4;
                dryCtx.lineCap = 'round';
                dryCtx.beginPath();
                dryCtx.moveTo(prevMouseX, prevMouseY);
                dryCtx.lineTo(x, y);
                dryCtx.stroke();
                dryCtx.restore();
            }
        }

        function animate() {
            // Clear main canvas for temporary effects
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw permanent dry layer first (all permanent marks)
            if (dryLayer.width > 0 && dryLayer.height > 0) {
                ctx.drawImage(dryLayer, 0, 0);
            }
            
            // Clear wet layer only for watercolor temporary effects
            if (currentBrush === 'watercolor') {
                wetCtx.clearRect(0, 0, wetLayer.width, wetLayer.height);
            }
            
            // Update and draw all particle types (these are temporary effects)
            particles = particles.filter(p => p.update() ? (p.draw(), true) : false);
            waterDroplets = waterDroplets.filter(d => d.update() ? (d.draw(), true) : false);
            waxParticles = waxParticles.filter(w => w.update() ? (w.draw(), true) : false);
            paintGlobs = paintGlobs.filter(g => g.update() ? (g.draw(), true) : false);
            
            // Draw wet layer on top for watercolor temporary effects
            if (currentBrush === 'watercolor' && wetLayer.width > 0 && wetLayer.height > 0) {
                ctx.drawImage(wetLayer, 0, 0);
            }

            requestAnimationFrame(animate);
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            strokeLength = 0;
            brushLoad = 1.0;
            strokeHistory = [{x: mouseX, y: mouseY}];
            createStroke(mouseX, mouseY);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            if (isDrawing) {
                const distance = Math.sqrt((mouseX - prevMouseX) ** 2 + (mouseY - prevMouseY) ** 2);
                strokeLength += distance;
                strokeHistory.push({x: mouseX, y: mouseY});
                
                const steps = currentBrush === 'crayon' ? 
                    Math.max(1, Math.floor(distance / 8)) : 
                    Math.max(1, Math.floor(distance / 5));
                
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = prevMouseX + (mouseX - prevMouseX) * t;
                    const y = prevMouseY + (mouseY - prevMouseY) * t;
                    createStroke(x, y);
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            strokeHistory = [];
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            strokeHistory = [];
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            isDrawing = true;
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            strokeLength = 0;
            brushLoad = 1.0;
            strokeHistory = [{x: mouseX, y: mouseY}];
            createStroke(mouseX, mouseY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            
            if (isDrawing) {
                const distance = Math.sqrt((mouseX - prevMouseX) ** 2 + (mouseY - prevMouseY) ** 2);
                strokeLength += distance;
                strokeHistory.push({x: mouseX, y: mouseY});
                
                const steps = currentBrush === 'crayon' ? 
                    Math.max(1, Math.floor(distance / 8)) : 
                    Math.max(1, Math.floor(distance / 5));
                
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = prevMouseX + (mouseX - prevMouseX) * t;
                    const y = prevMouseY + (mouseY - prevMouseY) * t;
                    createStroke(x, y);
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
            strokeHistory = [];
        });

        // Control updates
        document.getElementById('brushSelector').addEventListener('change', (e) => {
            switchBrush(e.target.value);
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('param1').addEventListener('input', (e) => {
            param1 = parseFloat(e.target.value);
            document.getElementById('param1Value').textContent = 
                e.target.step === '0.1' ? param1.toFixed(1) : param1;
        });

        document.getElementById('param2').addEventListener('input', (e) => {
            param2 = parseInt(e.target.value);
            document.getElementById('param2Value').textContent = param2;
        });

        document.getElementById('param3').addEventListener('input', (e) => {
            param3 = parseFloat(e.target.value);
            document.getElementById('param3Value').textContent = 
                e.target.step === '0.1' ? param3.toFixed(1) : param3;
        });

        document.getElementById('param4').addEventListener('input', (e) => {
            param4 = parseInt(e.target.value);
            document.getElementById('param4Value').textContent = param4;
        });

        document.getElementById('brushColor').addEventListener('input', (e) => {
            brushColor = e.target.value;
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            wetCtx.clearRect(0, 0, wetLayer.width, wetLayer.height);
            dryCtx.clearRect(0, 0, dryLayer.width, dryLayer.height);
            particles = [];
            waterDroplets = [];
            waxParticles = [];
            paintGlobs = [];
            strokeHistory = [];
        });

        document.getElementById('saveCanvas').addEventListener('click', () => {
            // Create a temporary canvas to combine all layers
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Fill with white background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw the dry layer (permanent marks)
            if (dryLayer.width > 0 && dryLayer.height > 0) {
                tempCtx.drawImage(dryLayer, 0, 0);
            }
            
            // Draw the main canvas (current temporary effects)
            tempCtx.drawImage(canvas, 0, 0);
            
            // Create download link
            const link = document.createElement('a');
            link.download = `painting_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initialize with flowing brush
        switchBrush('flowing');
        animate();
    </script>
</body>
</html>