<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Painting Studio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .controls {
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .brush-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            margin-right: 20px;
            padding-right: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .brush-selector label {
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            outline: none;
            min-width: 120px;
        }

        select option {
            background: #2a2a2a;
            color: #fff;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-height: 14px;
        }

        .control-description {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
            margin-top: 2px;
            min-height: 12px;
            text-align: center;
        }

        input[type="range"] {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--thumb-color, #ff6b6b);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.5);
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        #canvas {
            background: #ffffff;
            cursor: crosshair;
            flex: 1;
        }

        .value-display {
            color: var(--value-color, #ff6b6b);
            font-size: 11px;
            font-weight: bold;
        }

        /* Brush-specific theming */
        .flowing-theme {
            --thumb-color: #ff6b6b;
            --value-color: #ff6b6b;
        }

        .watercolor-theme {
            --thumb-color: #4a90e2;
            --value-color: #4a90e2;
        }

        .crayon-theme {
            --thumb-color: #d2691e;
            --value-color: #d2691e;
        }

        .oil-theme {
            --thumb-color: #8b4513;
            --value-color: #8b4513;
        }

        .pen-theme {
            --thumb-color: #000000;
            --value-color: #000000;
        }

        .rainbow-theme {
            --thumb-color: #ff6b6b;
            --value-color: #ff6b6b;
        }

        .wiggle-theme {
            --thumb-color: #ff7800;
            --value-color: #ff7800;
        }

        .spray-theme {
            --thumb-color: #000000;
            --value-color: #000000;
        }

        .fountain-theme {
            --thumb-color: #000000;
            --value-color: #000000;
        }

        .brush-info {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            color: #fff;
            font-size: 11px;
            max-width: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .brush-info.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="controls flowing-theme" id="controls">
        <div class="brush-selector">
            <label>Brush Type</label>
            <select id="brushSelector">
                <option value="flowing">Flowing Particle</option>
                <option value="watercolor">Watercolor</option>
                <option value="crayon">Crayon</option>
                <option value="oil">Oil Paint</option>
                <option value="marker">Marker</option>
                <option value="rainbow">Rainbow</option>
                <option value="wiggle">Wiggle</option>
                <option value="spray">Spray</option>
                <option value="fountain">Fountain</option>
            </select>
        </div>

        <div class="control-group">
            <label>Brush Size</label>
            <input type="range" id="brushSize" min="5" max="50" value="20">
            <span class="value-display" id="brushSizeValue">20</span>
        </div>

        <div class="control-group">
            <label id="param1Label">Flow Rate</label>
            <input type="range" id="param1" min="0.1" max="2" step="0.1" value="1.0">
            <span class="value-display" id="param1Value">1.0</span>
            <div class="control-description" id="param1Desc">Particle speed</div>
        </div>

        <div class="control-group">
            <label id="param2Label">Particles</label>
            <input type="range" id="param2" min="5" max="30" value="15">
            <span class="value-display" id="param2Value">15</span>
            <div class="control-description" id="param2Desc">Particle count</div>
        </div>

        <div class="control-group">
            <label id="param3Label">Turbulence</label>
            <input type="range" id="param3" min="0.1" max="2" step="0.1" value="1.0">
            <span class="value-display" id="param3Value">1.0</span>
            <div class="control-description" id="param3Desc">Chaos amount</div>
        </div>

        <div class="control-group">
            <label id="param4Label">Paper Roughness</label>
            <input type="range" id="param4" min="0" max="10" value="4">
            <span class="value-display" id="param4Value">4</span>
            <div class="control-description" id="param4Desc">Surface texture</div>
        </div>

        <div class="control-group">
            <label>Color</label>
            <input type="color" id="brushColor" value="#ff6b6b">
        </div>

        <button id="clearCanvas">Clear Canvas</button>
        <button id="saveCanvas">Save Canvas</button>
    </div>

    <div class="brush-info" id="brushInfo">
        <strong id="brushName">Flowing Particle Brush</strong><br>
        <span id="brushDescription">Dynamic particle system with flowing effects and turbulence.</span>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Canvas layers for different brush types
        const wetLayer = document.createElement('canvas');
        const wetCtx = wetLayer.getContext('2d');
        const dryLayer = document.createElement('canvas');
        const dryCtx = dryLayer.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            const controlsHeight = document.querySelector('.controls').offsetHeight;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - controlsHeight;
            wetLayer.width = canvas.width;
            wetLayer.height = canvas.height;
            dryLayer.width = canvas.width;
            dryLayer.height = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Unified settings
        let currentBrush = 'flowing';
        let brushSize = 20;
        let param1 = 1.0;
        let param2 = 15;
        let param3 = 1.0;
        let param4 = 4;
        let brushColor = '#ff6b6b';
        let frameCount = 0;

        // Particle systems
        let particles = [];
        let waterDroplets = [];
        let pigmentParticles = [];
        let waxParticles = [];
        let paintGlobs = [];
        let strokeHistory = [];
        let isDrawing = false;
        let mouseX = 0;
        let mouseY = 0;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let strokeLength = 0;
        let brushLoad = 1.0;

        // Brush configurations
        const brushConfigs = {
            flowing: {
                name: 'Flowing Particle Brush',
                description: 'Dynamic particle system with flowing effects and turbulence.',
                theme: 'flowing-theme',
                params: {
                    param1: { label: 'Flow Rate', desc: 'Particle speed', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Particles', desc: 'Particle count', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Turbulence', desc: 'Chaos amount', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Roughness', desc: 'Surface texture', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#ff6b6b'
            },
            watercolor: {
                name: 'Watercolor Brush',
                description: 'Realistic watercolor with bleeding and organic flow patterns.',
                theme: 'watercolor-theme',
                params: {
                    param1: { label: 'Water Content', desc: 'Controls bleeding', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Pigment Density', desc: 'Color intensity', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Flow Speed', desc: 'Water movement', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Texture', desc: 'Surface roughness', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#4a90e2'
            },
            crayon: {
                name: 'Crayon Brush',
                description: 'Textured waxy application with natural gaps and paper interaction.',
                theme: 'crayon-theme',
                params: {
                    param1: { label: 'Pressure', desc: 'Wax density', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Texture Strength', desc: 'Grain intensity', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Grain Size', desc: 'Texture scale', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Roughness', desc: 'Surface texture', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#d2691e'
            },
            oil: {
                name: 'Oil Paint Brush',
                description: 'Thick impasto application with natural paint depletion and streaking.',
                theme: 'oil-theme',
                params: {
                    param1: { label: 'Paint Thickness', desc: 'Impasto effect', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Viscosity', desc: 'Paint thickness', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Blending', desc: 'Edge softness', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Canvas Texture', desc: 'Surface drag', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#8b4513'
            },
            marker: {
                name: 'Marker Brush',
                description: 'Textured marker with natural gaps and paper interaction.',
                theme: 'pen-theme',
                params: {
                    param1: { label: 'Pressure', desc: 'Marker density', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param2: { label: 'Texture Strength', desc: 'Marker intensity', min: 5, max: 30, step: 1, default: 15 },
                    param3: { label: 'Grain Size', desc: 'Marker size', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Paper Roughness', desc: 'Surface texture', min: 0, max: 10, step: 1, default: 4 }
                },
                color: '#000000'
            },
            rainbow: {
                name: 'Rainbow Brush',
                description: 'Dynamic rainbow colors that change as you draw with flowing effects.',
                theme: 'rainbow-theme',
                params: {
                    param1: { label: 'Color Speed', desc: 'Color change rate', min: 0.1, max: 5, step: 0.1, default: 2.0 },
                    param2: { label: 'Bead Size', desc: 'Rainbow bead size', min: 5, max: 50, step: 1, default: 20 },
                    param3: { label: 'Saturation', desc: 'Color intensity', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Brightness', desc: 'Color brightness', min: 0.1, max: 2, step: 0.1, default: 1.0 }
                },
                color: '#ff6b6b'
            },
            wiggle: {
                name: 'Wiggle Brush',
                description: 'Playful wiggling lines with dynamic curves and organic movement.',
                theme: 'wiggle-theme',
                params: {
                    param1: { label: 'Wiggle Amount', desc: 'Curve intensity', min: 0.1, max: 3, step: 0.1, default: 1.5 },
                    param2: { label: 'Frequency', desc: 'Wiggle frequency', min: 1, max: 20, step: 1, default: 10 },
                    param3: { label: 'Smoothness', desc: 'Line smoothness', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Thickness', desc: 'Line thickness', min: 1, max: 10, step: 1, default: 3 }
                },
                color: '#ff7800'
            },
            spray: {
                name: 'Spray Brush',
                description: 'Spray paint effect with particle dispersion and texture.',
                theme: 'spray-theme',
                params: {
                    param1: { label: 'Spray Density', desc: 'Particle density', min: 10, max: 100, step: 5, default: 40 },
                    param2: { label: 'Spray Radius', desc: 'Spray area size', min: 5, max: 50, step: 1, default: 20 },
                    param3: { label: 'Speed Factor', desc: 'Movement sensitivity', min: 0.1, max: 3, step: 0.1, default: 1.0 },
                    param4: { label: 'Opacity', desc: 'Spray opacity', min: 0.1, max: 1, step: 0.1, default: 0.7 }
                },
                color: '#000000'
            },
            fountain: {
                name: 'Fountain Brush',
                description: 'Fountain pen with smooth, flowing lines and natural ink flow.',
                theme: 'fountain-theme',
                params: {
                    param1: { label: 'Line Width', desc: 'Pen width', min: 1, max: 10, step: 1, default: 4 },
                    param2: { label: 'Flow Rate', desc: 'Ink flow speed', min: 1, max: 20, step: 1, default: 12 },
                    param3: { label: 'Smoothness', desc: 'Line smoothness', min: 0.1, max: 2, step: 0.1, default: 1.0 },
                    param4: { label: 'Opacity', desc: 'Ink opacity', min: 0.1, max: 1, step: 0.1, default: 1.0 }
                },
                color: '#000000'
            }
        };

        // Switch brush type
        function switchBrush(brushType) {
            currentBrush = brushType;
            const config = brushConfigs[brushType];

            // Clear all particles
            particles = [];
            waterDroplets = [];
            pigmentParticles = [];
            waxParticles = [];
            paintGlobs = [];

            // Update theme
            const controls = document.getElementById('controls');
            controls.className = `controls ${config.theme}`;

            // Update brush info
            document.getElementById('brushName').textContent = config.name;
            document.getElementById('brushDescription').textContent = config.description;

            // Update parameter labels and settings
            Object.keys(config.params).forEach(paramKey => {
                const param = config.params[paramKey];
                const input = document.getElementById(paramKey);
                const label = document.getElementById(`${paramKey}Label`);
                const desc = document.getElementById(`${paramKey}Desc`);
                const value = document.getElementById(`${paramKey}Value`);

                label.textContent = param.label;
                desc.textContent = param.desc;
                input.min = param.min;
                input.max = param.max;
                input.step = param.step || 1;
                input.value = param.default;
                value.textContent = param.step === 0.1 ? param.default.toFixed(1) : param.default;

                // Update global variables
                window[paramKey] = param.default;
            });

            // Update brush color
            brushColor = config.color;
            document.getElementById('brushColor').value = config.color;

            // Show brush info briefly
            const brushInfo = document.getElementById('brushInfo');
            brushInfo.classList.add('visible');
            setTimeout(() => brushInfo.classList.remove('visible'), 3000);
        }

        // Convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Particle classes
        class FlowingParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.decay = 0.005 + Math.random() * 0.01;
                this.size = Math.random() * 3 + 1;
                this.color = color;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = (Math.random() - 0.5) * 0.1;
                this.trail = [];
                this.maxTrailLength = 8;
            }

            update() {
                // Add current position to trail
                this.trail.push({x: this.x, y: this.y, life: this.life});
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                this.angle += this.spin;
                this.vx += Math.cos(this.angle) * param3 * 0.01;
                this.vy += Math.sin(this.angle) * param3 * 0.01;
                this.x += this.vx * param1;
                this.y += this.vy * param1;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
                this.size *= 0.999;
                return this.life > 0;
            }

            draw() {
                // Draw trail on permanent canvas (dry layer)
                if (dryLayer.width > 0 && dryLayer.height > 0) {
                    for (let i = 0; i < this.trail.length; i++) {
                        const point = this.trail[i];
                        const alpha = (point.life * (i / this.trail.length)) * 0.3;
                        const size = this.size * (i / this.trail.length);

                        dryCtx.save();
                        dryCtx.globalAlpha = alpha;
                        dryCtx.fillStyle = this.color;
                        dryCtx.beginPath();
                        dryCtx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        dryCtx.fill();
                        dryCtx.restore();
                    }

                    // Draw permanent mark when particle is fresh
                    if (this.life > 0.8) {
                        dryCtx.save();
                        dryCtx.globalAlpha = 0.6;
                        dryCtx.fillStyle = this.color;
                        dryCtx.beginPath();
                        dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        dryCtx.fill();
                        dryCtx.restore();
                    }
                }

                // Draw glowing particle on main canvas (temporary effect)
                ctx.save();
                ctx.globalAlpha = this.life * 0.8;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class WaterDroplet {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.originalSize = size;
                this.vx = (Math.random() - 0.5) * param3;
                this.vy = (Math.random() - 0.5) * param3;
                this.life = 1.0;
                this.evaporation = 0.002 + Math.random() * 0.003;
                this.color = color;
                this.opacity = 0.3 + Math.random() * 0.4;
                this.spread = 0;
                this.maxSpread = param1 * 20;
                this.absorbed = false;
                this.permanentMarks = [];
            }

            update() {
                this.vy += 0.01;
                if (Math.random() < param4 * 0.01) {
                    this.vx += (Math.random() - 0.5) * 0.1;
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.spread += 0.5;
                this.size = this.originalSize + this.spread * 0.3;
                this.life -= this.evaporation;
                this.opacity *= 0.998;

                // Create permanent bleeding marks as the droplet moves
                if (this.spread > 2 && !this.absorbed) {
                    this.createPermanentMark();
                }

                if (this.spread > this.maxSpread * 0.7 && !this.absorbed) {
                    this.absorbIntoPaper();
                    this.absorbed = true;
                }
                return this.life > 0 && this.opacity > 0.01;
            }

            createPermanentMark() {
                const rgb = hexToRgb(this.color);
                if (rgb && dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity * 0.4;
                    const gradient = dryCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                    gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)`);
                    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                    dryCtx.fillStyle = gradient;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }
            }

            absorbIntoPaper() {
                const rgb = hexToRgb(this.color);
                if (rgb && dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity * 0.8;
                    const gradient = dryCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                    gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`);
                    gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                    dryCtx.fillStyle = gradient;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }
            }

            draw() {
                const rgb = hexToRgb(this.color);
                if (!rgb) return;
                wetCtx.save();
                wetCtx.globalAlpha = this.opacity;
                const gradient = wetCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.6)`);
                gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
                wetCtx.fillStyle = gradient;
                wetCtx.beginPath();
                wetCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                wetCtx.fill();
                wetCtx.restore();
            }
        }

        class WaxParticle {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.opacity = 0.6 + Math.random() * 0.4;
                this.settled = false;
                this.life = 1.0;
                this.decay = 0.002;
                this.displacement = { x: (Math.random() - 0.5) * param3, y: (Math.random() - 0.5) * param3 };
                this.paperSkip = Math.random() < (param4 * 0.01);
            }

            update() {
                if (!this.settled) {
                    this.x += this.displacement.x * 0.1;
                    this.y += this.displacement.y * 0.1;
                    this.displacement.x *= 0.9;
                    this.displacement.y *= 0.9;
                    if (Math.abs(this.displacement.x) < 0.1) this.settled = true;
                }
                this.life -= this.decay;
                return this.life > 0;
            }

            draw() {
                if (this.paperSkip) return;

                // Draw on permanent layer (dry layer) for consistency
                if (dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity * this.life;
                    dryCtx.fillStyle = this.color;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }

                // Also draw temporary effect on main canvas
                ctx.save();
                ctx.globalAlpha = this.opacity * this.life * 0.3;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class PaintGlob {
            constructor(x, y, color, size, thickness, strokePosition) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.thickness = thickness;
                this.color = color;
                this.strokePosition = strokePosition;
                this.opacity = this.calculateOpacity();
                this.life = 1.0;
                this.decay = 0.001;
                this.bleedRadius = 0;
                this.maxBleed = thickness * 2;
                this.viscousFlow = {
                    x: (Math.random() - 0.5) * 0.2 * (1 - param2 * 0.05),
                    y: (Math.random() - 0.5) * 0.2 * (1 - param2 * 0.05)
                };
            }

            calculateOpacity() {
                if (this.strokePosition < 0.3) {
                    return 0.85 + (this.thickness * 0.15);
                }
                const dragOpacity = Math.max(0.05, 0.7 - this.strokePosition * 0.6);
                if (this.strokePosition > 0.5 && Math.random() < (this.strokePosition - 0.5) * 0.8) {
                    return 0;
                }
                return dragOpacity;
            }

            update() {
                if (this.bleedRadius < this.maxBleed) {
                    this.bleedRadius += 0.05 * param3;
                    this.x += this.viscousFlow.x;
                    this.y += this.viscousFlow.y;
                    this.viscousFlow.x *= 0.95;
                    this.viscousFlow.y *= 0.95;
                }
                this.life -= this.decay;
                return this.life > 0;
            }

            draw() {
                if (this.opacity <= 0) return;
                const rgb = hexToRgb(this.color);
                if (!rgb) return;

                // Draw on permanent layer (dry layer) for consistency
                if (dryLayer.width > 0 && dryLayer.height > 0) {
                    dryCtx.save();
                    dryCtx.globalAlpha = this.opacity;
                    dryCtx.fillStyle = this.color;
                    dryCtx.beginPath();
                    dryCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    dryCtx.fill();
                    dryCtx.restore();
                }

                // Also draw temporary glow effect on main canvas
                ctx.save();
                ctx.globalAlpha = this.opacity * 0.3;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Create strokes based on current brush
        function createStroke(x, y) {
            switch (currentBrush) {
                case 'flowing':
                    createFlowingStroke(x, y);
                    break;
                case 'watercolor':
                    createWatercolorStroke(x, y);
                    break;
                case 'crayon':
                    createCrayonStroke(x, y);
                    break;
                case 'oil':
                    createOilPaintStroke(x, y);
                    break;
                case 'marker':
                    createMarkerStroke(x, y);
                    break;
                case 'rainbow':
                    createRainbowStroke(x, y);
                    break;
                case 'wiggle':
                    createWiggleStroke(x, y);
                    break;
                case 'spray':
                    createSprayStroke(x, y);
                    break;
                case 'fountain':
                    createFountainStroke(x, y);
                    break;
            }
        }

        function createFlowingStroke(x, y) {
            const count = Math.floor(param2 * param1);
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const radius = Math.random() * brushSize;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                particles.push(new FlowingParticle(px, py, brushColor));
            }

            // Create brush stroke connecting effect on permanent layer
            if (isDrawing && dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.globalAlpha = 0.3;
                dryCtx.strokeStyle = brushColor;
                dryCtx.lineWidth = brushSize * 0.3;
                dryCtx.lineCap = 'round';
                dryCtx.shadowBlur = 20;
                dryCtx.shadowColor = brushColor;
                dryCtx.beginPath();
                dryCtx.moveTo(prevMouseX, prevMouseY);
                dryCtx.lineTo(x, y);
                dryCtx.stroke();
                dryCtx.restore();
            }
        }

        function createWatercolorStroke(x, y) {
            const waterDropCount = Math.floor(brushSize * param1 * 0.3);
            for (let i = 0; i < waterDropCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * brushSize;
                const wx = x + Math.cos(angle) * radius;
                const wy = y + Math.sin(angle) * radius;
                const dropSize = 3 + Math.random() * 8;
                waterDroplets.push(new WaterDroplet(wx, wy, dropSize, brushColor));
            }
        }

        function createCrayonStroke(x, y) {
            const patchCount = Math.floor(brushSize * 0.8);
            for (let i = 0; i < patchCount; i++) {
                if (Math.random() < 0.4 + (param4 * 0.05)) continue;
                const angle = (Math.PI * 2 * i) / patchCount;
                const radius = Math.random() * brushSize * 0.8;
                const patchX = x + Math.cos(angle) * radius;
                const patchY = y + Math.sin(angle) * radius;
                const patchSize = (Math.random() * 3 + 1) * param1;
                waxParticles.push(new WaxParticle(patchX, patchY, brushColor, patchSize));
            }
        }

        function createOilPaintStroke(x, y) {
            const strokePos = Math.min(1, strokeLength / (brushSize * 8));
            brushLoad = Math.max(0.1, 1 - strokePos * 0.8);
            const baseParticleCount = strokePos < 0.3 ?
                Math.floor(param2 * 0.4) :
                Math.floor(param2 * (1 + strokePos * 1.5));
            const mainGlobCount = Math.floor(baseParticleCount * param1 * brushLoad);

            for (let i = 0; i < mainGlobCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * brushSize * (strokePos < 0.3 ? 0.6 : 1.2);
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                const globSize = strokePos < 0.3 ?
                    (Math.random() * 2 + 3) * param1 * brushLoad :
                    (Math.random() * 4 + 1) * param1 * Math.max(0.2, brushLoad);
                paintGlobs.push(new PaintGlob(px, py, brushColor, globSize, param1, strokePos));
            }
        }

        function createMarkerStroke(x, y) {
            // Marker brush with textured application based on SuperHi techniques
            const markerSize = brushSize * param3; // Grain size
            const markerCount = Math.floor(param2 * 0.5); // Texture strength

            // Use lerping for smoother marker strokes like in the SuperHi guide
            const lerps = 8;

            for (let i = 0; i < lerps; i++) {
                const t = i / lerps;
                const lerpX = prevMouseX + (x - prevMouseX) * t;
                const lerpY = prevMouseY + (y - prevMouseY) * t;

                for (let j = 0; j < markerCount; j++) {
                    // Add paper roughness effect like in the guide
                    if (Math.random() < 0.3 + (param4 * 0.05)) continue;

                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * markerSize;
                    const markerX = lerpX + Math.cos(angle) * radius;
                    const markerY = lerpY + Math.sin(angle) * radius;
                    const size = (Math.random() * 3 + 2) * param1; // Pressure affects size

                    if (dryLayer.width > 0 && dryLayer.height > 0) {
                        dryCtx.save();
                        dryCtx.fillStyle = brushColor;
                        dryCtx.globalAlpha = 0.4;
                        dryCtx.beginPath();
                        dryCtx.arc(markerX, markerY, size, 0, Math.PI * 2);
                        dryCtx.fill();
                        dryCtx.restore();
                    }
                }
            }
        }

        function createRainbowStroke(x, y) {
            // Dynamic rainbow colors that change as you draw with proper circle effects
            const hue = (frameCount * param1 * 10) % 360; // Color speed
            const saturation = Math.min(100, 70 * param3); // Saturation (0-100)
            const brightness = Math.min(100, 90 * param4); // Brightness (0-100)

            // Convert HSL to RGB for proper color display
            const h = hue / 360;
            const s = saturation / 100;
            const l = brightness / 100;

            let r, g, b;

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            const rainbowColor = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, 0.6)`;

            if (isDrawing && dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.fillStyle = rainbowColor;
                dryCtx.globalAlpha = 0.6;

                // Find the distance between current and previous mouse points like in SuperHi guide
                const distance = Math.sqrt((x - prevMouseX) ** 2 + (y - prevMouseY) ** 2);
                // Find the midpoint between current and previous mouse points
                const midX = (x + prevMouseX) / 2;
                const midY = (y + prevMouseY) / 2;

                // Create rainbow circles/beads using the distance
                const beadSize = param2; // Bead size
                dryCtx.beginPath();
                dryCtx.arc(midX, midY, Math.min(distance, beadSize), 0, Math.PI * 2);
                dryCtx.fill();
                dryCtx.restore();
            }
        }

        function createWiggleStroke(x, y) {
            // Playful wiggling lines with dynamic curves based on SuperHi techniques
            if (isDrawing && dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.strokeStyle = brushColor;
                dryCtx.lineWidth = param4; // Thickness
                dryCtx.lineCap = 'round';
                dryCtx.globalAlpha = 1.0;

                // Find the distance between current and previous mouse points
                const distance = Math.sqrt((x - prevMouseX) ** 2 + (y - prevMouseY) ** 2);
                const midX = (x + prevMouseX) / 2;
                const midY = (y + prevMouseY) / 2;

                // Find the angle of the direction the mouse is moving in
                const angle = Math.atan2(y - prevMouseY, x - prevMouseX);
                const wiggleAmount = param1; // Wiggle amount
                const frequency = param2; // Frequency

                // Use state-based flipping like in the SuperHi guide
                const flip = (frameCount % 2) * Math.PI;

                dryCtx.beginPath();
                dryCtx.arc(midX, midY, distance, angle + flip, angle + Math.PI + flip);
                dryCtx.stroke();
                dryCtx.restore();
            }
        }

        function createSprayStroke(x, y) {
            // Spray paint effect with particle dispersion based on SuperHi techniques
            const sprayDensity = param1; // Spray density
            const sprayRadius = param2; // Spray radius
            const speedFactor = param3; // Speed factor
            const opacity = param4; // Opacity

            // Find the speed of the mouse movement like in the SuperHi guide
            const speed = Math.abs(x - prevMouseX) + Math.abs(y - prevMouseY);

            // Set minimum radius and calculate actual radius
            const minRadius = 8;
            const r = speed * speedFactor + minRadius;
            const rSquared = r * r;

            // Set the number of times we lerp the points like in the guide
            const lerps = 6;

            // Repeat the random points with lerping
            for (let i = 0; i < lerps; i++) {
                // Find the lerped X and Y coordinates
                const lerpX = prevMouseX + (x - prevMouseX) * (i / lerps);
                const lerpY = prevMouseY + (y - prevMouseY) * (i / lerps);

                // Draw random points within a circle using SuperHi technique
                for (let j = 0; j < sprayDensity; j++) {
                    // Pick a random position within the circle using the guide's formula
                    const randX = (Math.random() - 0.5) * r * 2;
                    const randY = (Math.random() - 0.5) * Math.sqrt(rSquared - randX * randX);

                    if (dryLayer.width > 0 && dryLayer.height > 0) {
                        dryCtx.save();
                        dryCtx.fillStyle = brushColor;
                        dryCtx.globalAlpha = opacity;
                        dryCtx.beginPath();
                        dryCtx.arc(lerpX + randX, lerpY + randY, 1, 0, Math.PI * 2);
                        dryCtx.fill();
                        dryCtx.restore();
                    }
                }
            }
        }

        function createFountainStroke(x, y) {
            // Fountain pen with smooth, flowing lines based on SuperHi techniques
            const lineWidth = param1; // Line width
            const flowRate = param2; // Flow rate
            const smoothness = param3; // Smoothness
            const opacity = param4; // Opacity

            if (isDrawing && dryLayer.width > 0 && dryLayer.height > 0) {
                dryCtx.save();
                dryCtx.strokeStyle = brushColor;
                dryCtx.lineWidth = lineWidth;
                dryCtx.lineCap = 'round';
                dryCtx.globalAlpha = opacity;

                // Use lerping for smoother fountain pen strokes like in the SuperHi guide
                const lerps = Math.floor(flowRate);

                for (let i = 0; i < lerps; i++) {
                    const t = i / lerps;
                    const strokeX = prevMouseX + (x - prevMouseX) * t;
                    const strokeY = prevMouseY + (y - prevMouseY) * t;

                    // Draw diagonal lines for fountain pen effect like in the guide
                    dryCtx.beginPath();
                    dryCtx.moveTo(strokeX - lineWidth * 0.5, strokeY - lineWidth * 0.5);
                    dryCtx.lineTo(strokeX + lineWidth * 0.5, strokeY + lineWidth * 0.5);
                    dryCtx.stroke();
                }
                dryCtx.restore();
            }
        }

        function animate() {
            // Increment frame count for animations
            frameCount++;

            // Clear main canvas for temporary effects
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw permanent dry layer first (all permanent marks)
            if (dryLayer.width > 0 && dryLayer.height > 0) {
                ctx.drawImage(dryLayer, 0, 0);
            }

            // Clear wet layer only for watercolor temporary effects
            if (currentBrush === 'watercolor') {
                wetCtx.clearRect(0, 0, wetLayer.width, wetLayer.height);
            }

            // Update and draw all particle types (these are temporary effects)
            particles = particles.filter(p => p.update() ? (p.draw(), true) : false);
            waterDroplets = waterDroplets.filter(d => d.update() ? (d.draw(), true) : false);
            waxParticles = waxParticles.filter(w => w.update() ? (w.draw(), true) : false);
            paintGlobs = paintGlobs.filter(g => g.update() ? (g.draw(), true) : false);

            // Draw wet layer on top for watercolor temporary effects
            if (currentBrush === 'watercolor' && wetLayer.width > 0 && wetLayer.height > 0) {
                ctx.drawImage(wetLayer, 0, 0);
            }

            requestAnimationFrame(animate);
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            strokeLength = 0;
            brushLoad = 1.0;
            strokeHistory = [{x: mouseX, y: mouseY}];
            createStroke(mouseX, mouseY);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (isDrawing) {
                const distance = Math.sqrt((mouseX - prevMouseX) ** 2 + (mouseY - prevMouseY) ** 2);
                strokeLength += distance;
                strokeHistory.push({x: mouseX, y: mouseY});

                const steps = currentBrush === 'crayon' ?
                    Math.max(1, Math.floor(distance / 8)) :
                    Math.max(1, Math.floor(distance / 5));

                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = prevMouseX + (mouseX - prevMouseX) * t;
                    const y = prevMouseY + (mouseY - prevMouseY) * t;
                    createStroke(x, y);
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            strokeHistory = [];
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            strokeHistory = [];
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            isDrawing = true;
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            strokeLength = 0;
            brushLoad = 1.0;
            strokeHistory = [{x: mouseX, y: mouseY}];
            createStroke(mouseX, mouseY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;

            if (isDrawing) {
                const distance = Math.sqrt((mouseX - prevMouseX) ** 2 + (mouseY - prevMouseY) ** 2);
                strokeLength += distance;
                strokeHistory.push({x: mouseX, y: mouseY});

                const steps = currentBrush === 'crayon' ?
                    Math.max(1, Math.floor(distance / 8)) :
                    Math.max(1, Math.floor(distance / 5));

                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = prevMouseX + (mouseX - prevMouseX) * t;
                    const y = prevMouseY + (mouseY - prevMouseY) * t;
                    createStroke(x, y);
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
            strokeHistory = [];
        });

        // Control updates
        document.getElementById('brushSelector').addEventListener('change', (e) => {
            switchBrush(e.target.value);
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('param1').addEventListener('input', (e) => {
            param1 = parseFloat(e.target.value);
            document.getElementById('param1Value').textContent =
                e.target.step === '0.1' ? param1.toFixed(1) : param1;
        });

        document.getElementById('param2').addEventListener('input', (e) => {
            param2 = parseInt(e.target.value);
            document.getElementById('param2Value').textContent = param2;
        });

        document.getElementById('param3').addEventListener('input', (e) => {
            param3 = parseFloat(e.target.value);
            document.getElementById('param3Value').textContent =
                e.target.step === '0.1' ? param3.toFixed(1) : param3;
        });

        document.getElementById('param4').addEventListener('input', (e) => {
            param4 = parseInt(e.target.value);
            document.getElementById('param4Value').textContent = param4;
        });

        document.getElementById('brushColor').addEventListener('input', (e) => {
            brushColor = e.target.value;
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            wetCtx.clearRect(0, 0, wetLayer.width, wetLayer.height);
            dryCtx.clearRect(0, 0, dryLayer.width, dryLayer.height);
            particles = [];
            waterDroplets = [];
            waxParticles = [];
            paintGlobs = [];
            strokeHistory = [];
        });

        document.getElementById('saveCanvas').addEventListener('click', () => {
            // Create a temporary canvas to combine all layers
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            // Fill with white background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw the dry layer (permanent marks)
            if (dryLayer.width > 0 && dryLayer.height > 0) {
                tempCtx.drawImage(dryLayer, 0, 0);
            }

            // Draw the main canvas (current temporary effects)
            tempCtx.drawImage(canvas, 0, 0);

            // Create download link
            const link = document.createElement('a');
            link.download = `painting_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
            link.href = tempCanvas.toDataURL('image/png');

            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initialize with flowing brush
        switchBrush('flowing');
        animate();
    </script>
</body>
</html>
